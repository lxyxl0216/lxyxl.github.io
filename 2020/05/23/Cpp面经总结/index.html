<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://lxyxl0216.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="c++的面试总结">
<meta name="keywords" content="面经">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp面经总结">
<meta property="og:url" content="https:&#x2F;&#x2F;lxyxl0216.github.io&#x2F;2020&#x2F;05&#x2F;23&#x2F;Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93&#x2F;index.html">
<meta property="og:site_name" content="李小阳小李">
<meta property="og:description" content="c++的面试总结">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;lxyxl0216.github.io&#x2F;2020&#x2F;05&#x2F;23&#x2F;Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93&#x2F;三次握手.webp">
<meta property="og:image" content="https:&#x2F;&#x2F;lxyxl0216.github.io&#x2F;2020&#x2F;05&#x2F;23&#x2F;Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93&#x2F;四次握手.jpeg">
<meta property="og:image" content="https:&#x2F;&#x2F;lxyxl0216.github.io&#x2F;2020&#x2F;05&#x2F;23&#x2F;Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93&#x2F;两次握手.png">
<meta property="og:image" content="https:&#x2F;&#x2F;lxyxl0216.github.io&#x2F;2020&#x2F;05&#x2F;23&#x2F;Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93&#x2F;OSI+TCP.png">
<meta property="og:image" content="https:&#x2F;&#x2F;lxyxl0216.github.io&#x2F;2020&#x2F;05&#x2F;23&#x2F;Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93&#x2F;socket.png">
<meta property="og:image" content="https:&#x2F;&#x2F;lxyxl0216.github.io&#x2F;2020&#x2F;05&#x2F;23&#x2F;Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;Cpp面经总结&#x2F;308571_1552654687053_263E6AFD1A48F8511D04B67EB12AA24C">
<meta property="og:updated_time" content="2020-05-23T07:53:50.851Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;lxyxl0216.github.io&#x2F;2020&#x2F;05&#x2F;23&#x2F;Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93&#x2F;三次握手.webp">

<link rel="canonical" href="https://lxyxl0216.github.io/2020/05/23/Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Cpp面经总结 | 李小阳小李</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
<script src="\assets\js\Meting.min.js" class="meting-script-marker"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李小阳小李</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">水低为海，人地为王</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-music">

    <a href="/music/" rel="section"><i class="fa fa-fw fa-music"></i>music</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lxyxl0216.github.io/2020/05/23/Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alex Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李小阳小李">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cpp面经总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-23 15:45:28 / 修改时间：15:53:50" itemprop="dateCreated datePublished" datetime="2020-05-23T15:45:28+08:00">2020-05-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="c-的面试总结"><a href="#c-的面试总结" class="headerlink" title="c++的面试总结"></a>c++的面试总结</h1><a id="more"></a>

    <div id="aplayer-ptasboIL" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="3072684435" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="new-delet和malloc-free的区别"><a href="#new-delet和malloc-free的区别" class="headerlink" title="new/delet和malloc/free的区别"></a>new/delet和malloc/free的区别</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">C++中的关键字</th>
<th style="text-align:center">C语言的函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">new会调用构造函数，不用指定内存大小</td>
<td style="text-align:center">需要给定申请内存的大小</td>
</tr>
<tr>
<td style="text-align:center">返回的指针是对象类型的指针类型，严格与对象匹配，无须进行类型转换。</td>
<td style="text-align:center">返回void <em> ，需要通过强制类型转换将void</em>指针转换成我们需要的类型。</td>
</tr>
<tr>
<td style="text-align:center">new操作符从自由存储区（free store）上为对象动态分配内存空间</td>
<td style="text-align:center">而malloc函数从堆上动态分配内存</td>
</tr>
<tr>
<td style="text-align:center">new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL</td>
<td style="text-align:center">malloc分配内存失败时返回NULL。</td>
</tr>
<tr>
<td style="text-align:center">调用构造函数/析构函数</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">可以重载</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区 </p>
</blockquote>
<h2 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h2><ul>
<li>全局静态变量<ul>
<li>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。</li>
<li>存储在静态存储区，在整个程序运行期间一直存在。</li>
<li>未初始化的全局静态变量会自动初始化为0。</li>
<li>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。 </li>
</ul>
</li>
<li>局部静态变量<ul>
<li>局部变量就成为一个局部静态变量。 </li>
<li>存储在 静态存储区。 </li>
<li>未经初始化的局部静态变量会被自动初始化为0。</li>
<li>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。 </li>
</ul>
</li>
<li>静态函数<ul>
<li>在函数返回类型前加static，函数就定义为静态函数。 </li>
<li>函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。 </li>
</ul>
</li>
<li>类的静态成员<ul>
<li>静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。 </li>
<li>静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。 </li>
</ul>
</li>
<li>类的静态函数<ul>
<li>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。 </li>
<li>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;); </li>
</ul>
</li>
</ul>
<h2 id="C-和C的区别"><a href="#C-和C的区别" class="headerlink" title="C++和C的区别"></a>C++和C的区别</h2><ul>
<li>设计思想上<ul>
<li>C++是面向对象的语言，而C是面向过程的结构化编程语言。</li>
</ul>
</li>
<li>语法上：<ul>
<li>C++具有封装继承和多态三种特性</li>
<li>C++支持范式编程比如模板类、函数模板。</li>
</ul>
</li>
<li>C是面向过程的语言，是一个结构化的语言，考虑如何通过一个过程对输入进行处理得到输出；C++是面向对象的语言，主要特征是“封装、继承和多态”。封装隐藏了实现细节，使得代码模块化；派生类可以继承父类的数据和方法，扩展了已经存在的模块，实现了代码重用；多态则是“一个接口，多种实现”，通过派生类重写父类的虚函数，实现了接口的重用。 </li>
<li>C和C++动态管理内存的方法不一样，C是使用malloc/free，而C++除此之外还有new/delete关键字。</li>
<li>C++支持函数重载，C不支持函数重载  </li>
<li>C++中有引用，C中不存在引用的概念 </li>
</ul>
<h2 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h2><ul>
<li>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。</li>
<li>举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。 </li>
</ul>
<h2 id="什么是虚函数"><a href="#什么是虚函数" class="headerlink" title="什么是虚函数"></a>什么是虚函数</h2><ul>
<li>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。</li>
<li>当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。 </li>
</ul>
<h2 id="静态函数和虚函数的区别"><a href="#静态函数和虚函数的区别" class="headerlink" title="静态函数和虚函数的区别"></a>静态函数和虚函数的区别</h2><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销 </p>
<h2 id="C-中四种cast转换"><a href="#C-中四种cast转换" class="headerlink" title="C++中四种cast转换"></a>C++中四种cast转换</h2><p>C++中四种类型转换是：<code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code></p>
<ol>
<li>const_cast：用于将const变量转为非const</li>
<li>static_cast：用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</li>
<li><p>dynamic_cast：用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p>
<ul>
<li><p>向上转换：指的是子类向基类的转换</p>
</li>
<li><p>向下转换：指的是基类向子类的转换</p>
</li>
<li><p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p>
</li>
</ul>
</li>
<li><p>reinterpret_cast：几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p>
</li>
<li>为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</li>
</ol>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指针</th>
<th style="text-align:center">引用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">指针有自己的一块空间</td>
<td style="text-align:center">引用只是一个别名</td>
</tr>
<tr>
<td style="text-align:center">sizeof看一个指针的大小是4</td>
<td style="text-align:center">引用则是被引用对象的大小</td>
</tr>
<tr>
<td style="text-align:center">指针可以被初始化为NULL</td>
<td style="text-align:center">引用必须被初始化</td>
</tr>
<tr>
<td style="text-align:center">作为参数传递时，指针需要被解引用才可以对对象进行操作</td>
<td style="text-align:center">直接对引用的修改都会改变引用所指向的对象</td>
</tr>
<tr>
<td style="text-align:center">指针在使用中可以指向其它对象</td>
<td style="text-align:center">引用只能是一个对象的引用，不能被改变</td>
</tr>
<tr>
<td style="text-align:center">指针可以有多级指针（**p）</td>
<td style="text-align:center">引用只有一级</td>
</tr>
<tr>
<td style="text-align:center">指针++表示地址指向的地址增加</td>
<td style="text-align:center">引用++表示+1</td>
</tr>
<tr>
<td style="text-align:center">返回动态内存分配的对象或者内存，必须使用指针</td>
<td style="text-align:center">引用可能引起内存泄露。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="指针和数组的区别"><a href="#指针和数组的区别" class="headerlink" title="指针和数组的区别"></a>指针和数组的区别</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指针</th>
<th style="text-align:center">数组</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">保存数据的地址</td>
<td style="text-align:center">保存数据</td>
</tr>
<tr>
<td style="text-align:center">间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据</td>
<td style="text-align:center">直接访问数据</td>
</tr>
<tr>
<td style="text-align:center">通常用于动态的数据结构</td>
<td style="text-align:center">用于固定数目且数据类型相同的元素</td>
</tr>
<tr>
<td style="text-align:center">通过Malloc分配内存，free释放内存</td>
<td style="text-align:center">隐式的分配和删除</td>
</tr>
<tr>
<td style="text-align:center">通常指向匿名数据，操作匿名函数</td>
<td style="text-align:center">自身即为数据名</td>
</tr>
</tbody>
</table>
</div>
<h2 id="什么是野指针"><a href="#什么是野指针" class="headerlink" title="什么是野指针"></a>什么是野指针</h2><p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针 </p>
<h2 id="C-的四个智能指针"><a href="#C-的四个智能指针" class="headerlink" title="C++的四个智能指针"></a>C++的四个智能指针</h2><p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。 </p>
<p>C++里面的四个智能指针: <code>auto_ptr</code>, <code>shared_ptr</code>, <code>weak_ptr</code>, <code>unique_ptr</code>其中后三个是c++11支持，并且第一个已经被11弃用。</p>
<p>为什么要使用智能指针：</p>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>
<ul>
<li>auto_ptr采用所有权模式。缺点是：存在潜在的内存崩溃问题！ </li>
<li>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。 </li>
<li>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。 </li>
<li>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。 </li>
</ul>
<h2 id="为什么析构函数必须是虚函数？"><a href="#为什么析构函数必须是虚函数？" class="headerlink" title="为什么析构函数必须是虚函数？"></a>为什么析构函数必须是虚函数？</h2><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。 </p>
<h2 id="为什么C-默认的析构函数不是虚函数"><a href="#为什么C-默认的析构函数不是虚函数" class="headerlink" title="为什么C++默认的析构函数不是虚函数"></a>为什么C++默认的析构函数不是虚函数</h2><p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。 </p>
<h2 id="析构函数的作用"><a href="#析构函数的作用" class="headerlink" title="析构函数的作用"></a>析构函数的作用</h2><ul>
<li><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。 </p>
</li>
<li><p>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<code>~</code>。</p>
</li>
<li>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数 </li>
<li>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么需要运行析构函数在释放对象的内存之前，释放掉申请的内存空间，避免内存泄漏。 </li>
<li>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。 </li>
</ul>
<h2 id="什么是函数指针"><a href="#什么是函数指针" class="headerlink" title="什么是函数指针"></a>什么是函数指针</h2><p>函数指针是指向函数的指针变量。函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。</p>
<p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>
<h2 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h2><ul>
<li>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中。</li>
<li>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写。</li>
</ul>
<h2 id="strcpy和strlen"><a href="#strcpy和strlen" class="headerlink" title="strcpy和strlen"></a>strcpy和strlen</h2><ul>
<li>strcpy是字符串拷贝函数，原型：<code>char *strcpy(char* dest, const char *src)</code>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。</li>
<li>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</li>
</ul>
<h2 id="C语言是怎么进行函数调用的"><a href="#C语言是怎么进行函数调用的" class="headerlink" title="C语言是怎么进行函数调用的"></a>C语言是怎么进行函数调用的</h2><p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针( 扩展栈指针寄存器 )压栈。 </p>
<h2 id="C-如何处理返回值"><a href="#C-如何处理返回值" class="headerlink" title="C++如何处理返回值"></a>C++如何处理返回值</h2><p>生成一个临时变量，把它的引用作为函数参数传入函数内。 </p>
<h2 id="C-中拷贝赋值函数的形参能否进行值传递？"><a href="#C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="C++中拷贝赋值函数的形参能否进行值传递？"></a>C++中拷贝赋值函数的形参能否进行值传递？</h2><p>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。 </p>
<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><ul>
<li>public</li>
</ul>
<p>公共的意思，用这个修饰结构或者类的成员变量，就可以被外界访问。</p>
<p>一般我们需要能够被外界访问的东西，就定义为public。</p>
<ul>
<li>private</li>
</ul>
<p>私有的意思，用这个修饰结构或者类的成员变量，只有被内部定义的成员函数才能访问使用。</p>
<ul>
<li>protected</li>
</ul>
<p>只允许本类或子类的成员函数来访问。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">基类中的访问权限</th>
<th style="text-align:center">子类继承基类的继承方式</th>
<th style="text-align:center">子类得到的访问权限</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">public</td>
<td style="text-align:center">public</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">public</td>
<td style="text-align:center">protected</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">public</td>
<td style="text-align:center">子类无权访问</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">protected</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">protected</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">子类无权访问</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">private</td>
<td style="text-align:center">private</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">private</td>
<td style="text-align:center">private</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">private</td>
<td style="text-align:center">子类无权访问</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>子类public继承父类不改变父类的访问权限</li>
<li>protected继承将父类中public权限变成protected</li>
<li>private继承使所有权限变成private</li>
<li>父类的private不受继承影响，子类无权访问</li>
</ol>
<h2 id="结构体和类有什么区别"><a href="#结构体和类有什么区别" class="headerlink" title="结构体和类有什么区别"></a>结构体和类有什么区别</h2><p>不管是C还是C++，结构都用struct定义</p>
<ul>
<li>类只在c++中存在</li>
<li>结构体用struct定义，类用class定义</li>
<li>在c中定义一个属于该结构的变量就做结构变量，在c++中定义一个属于类的变量，就做对象</li>
<li>c++结构内定义的成员变量和成员函数默认都是public，类内定义的都是private</li>
<li>c++结构体继承都是public，类的默认继承都是private</li>
</ul>
<h2 id="C-11有哪些新特性？"><a href="#C-11有哪些新特性？" class="headerlink" title="C++11有哪些新特性？"></a>C++11有哪些新特性？</h2><ul>
<li><p>auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导</p>
</li>
<li><p>nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。</p>
</li>
<li><p>智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。</p>
</li>
<li><p>初始化列表：使用初始化列表来对类进行初始化</p>
</li>
<li><p>右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</p>
</li>
<li><p>新增STL容器array以及tuple</p>
</li>
</ul>
<h2 id="结构体struct和共同体union（联合）的区别"><a href="#结构体struct和共同体union（联合）的区别" class="headerlink" title="结构体struct和共同体union（联合）的区别"></a>结构体struct和共同体union（联合）的区别</h2><p>结构体：将不同类型的数据组合成一个整体，是自定义类型</p>
<p>共同体：不同类型的几个变量共同占用一段内存</p>
<p>1）结构体中的每个成员都有自己独立的地址，它们是同时存在的；</p>
<p>共同体中的所有成员占用同一段内存，它们不能同时存在；</p>
<p>2）sizeof(struct)是内存对齐后所有成员长度的总和，sizeof(union)是内存对齐后最长数据成员的长度、</p>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="STL有什么基本组成"><a href="#STL有什么基本组成" class="headerlink" title="STL有什么基本组成"></a>STL有什么基本组成</h2><p>STL主要由：以下几部分组成：容器、迭代器、仿函数、算法、分配器、配接器<br>他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数 </p>
<h2 id="map和set"><a href="#map和set" class="headerlink" title="map和set"></a>map和set</h2><div class="table-container">
<table>
<thead>
<tr>
<th>map</th>
<th>set</th>
</tr>
</thead>
<tbody>
<tr>
<td>map中的元素是key-value（关键字—值）对</td>
<td>Set就是关键字的简单集合，set中每个元素只包含一个关键字</td>
</tr>
<tr>
<td>map允许修改value，但不允许修改key</td>
<td>set的迭代器是const的，不允许修改元素的值</td>
</tr>
<tr>
<td>map可以用key做下标</td>
<td>set不支持下标操作</td>
</tr>
<tr>
<td>关联容器</td>
<td>关联容器</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。 </p>
</blockquote>
<h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><ul>
<li>底层实现为hash表</li>
</ul>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><ul>
<li>多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。 </li>
<li>底层实现为红黑树</li>
<li>有序键值对可重复映射 </li>
</ul>
<h2 id="Vector-和-List"><a href="#Vector-和-List" class="headerlink" title="Vector 和 List"></a>Vector 和 List</h2><div class="table-container">
<table>
<thead>
<tr>
<th>vector</th>
<th>list</th>
</tr>
</thead>
<tbody>
<tr>
<td>连续存储的容器，动态数组，在堆上分配空间</td>
<td>动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。</td>
</tr>
<tr>
<td>底层实现：数组</td>
<td>底层：双向链表</td>
</tr>
<tr>
<td>插入新元素如果空间不够，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。</td>
<td></td>
</tr>
<tr>
<td>访问O(1)</td>
<td>随机访问性能很差，只能快速访问头尾节点。</td>
</tr>
<tr>
<td>适用场景：经常随机访问，且不经常对非尾节点进行插入删除。</td>
<td>适用场景：经常插入删除大量数据</td>
</tr>
<tr>
<td>顺序内存</td>
</tr>
</tbody>
</table>
</div>
<h2 id="STL迭代器删除元素"><a href="#STL迭代器删除元素" class="headerlink" title="STL迭代器删除元素"></a>STL迭代器删除元素</h2><ol>
<li>对于序列容器vector和deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器</li>
<li>对于关联容器map和set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。</li>
<li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。 </li>
</ol>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h2><p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p>
<p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。</p>
<h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><ol>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</li>
<li>进程是资源分配的最小单位，线程是CPU调度的最小单位；</li>
<li>系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</li>
<li>进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉 。</li>
<li>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。 </li>
<li>进程适应于多核、多机分布；线程适用于多核。 </li>
</ol>
<h2 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h2><p>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p>
<ol>
<li><p>管道：管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p>
<ul>
<li><p>普通管道PIPE：</p>
<ul>
<li><p>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</p>
</li>
<li><p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</p>
</li>
<li><p>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p>
</li>
</ul>
</li>
<li><p>命名管道FIFO：</p>
<ul>
<li><p>FIFO可以在无关的进程之间交换数据</p>
</li>
<li><p>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>系统IPC：</p>
<ul>
<li><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p>
<ul>
<li><p>特点：</p>
<ul>
<li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</li>
</ul>
</li>
<li><p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
</li>
<li><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>信号量semaphore</p>
<ul>
<li>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据</li>
<li>特点：<ul>
<li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li>
<li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</li>
<li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li>
<li>支持信号量组。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>信号signal</p>
<ul>
<li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ul>
</li>
</ul>
<ul>
<li><p>共享内存（Shared Memory）</p>
<ul>
<li><p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>共享内存是最快的一种IPC，因为进程是直接对内存进行存取</p>
</li>
<li><p>因为多个进程可以同时操作，所以需要进行同步</p>
</li>
</ul>
</li>
<li><p>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>套接字SOCKET：</p>
<ul>
<li>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。</li>
</ul>
</li>
</ol>
<h2 id="并发-concurrency-和并行-parallelism"><a href="#并发-concurrency-和并行-parallelism" class="headerlink" title="并发(concurrency)和并行(parallelism)"></a>并发(concurrency)和并行(parallelism)</h2><ul>
<li><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p>
</li>
<li><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p>
</li>
</ul>
<h2 id="多线程和多进程的不同"><a href="#多线程和多进程的不同" class="headerlink" title="多线程和多进程的不同"></a>多线程和多进程的不同</h2><ul>
<li><p>进程是资源分配的最小单位，而线程时CPU调度的最小单位。</p>
</li>
<li><p>多线程之间共享同一个进程的地址空间。线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。</p>
</li>
<li>多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强。进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布。 </li>
</ul>
<h2 id="如何定义多线程"><a href="#如何定义多线程" class="headerlink" title="如何定义多线程"></a>如何定义多线程</h2><p>在一个应用程序（进程）中同时执行多个小的部分（线程），这就是多线程。多个线程虽然共享一样的数据，但是却执行不同的任务。 c++中的并发就是利用多线程实现。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP的建立与断开过程"><a href="#TCP的建立与断开过程" class="headerlink" title="TCP的建立与断开过程"></a>TCP的建立与断开过程</h2><p><img src="/2020/05/23/Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/三次握手.webp" alt="TCP"></p>
<p>三次握手：</p>
<ol>
<li>Client将标志位<code>SYN</code>置为<code>1</code>，随机产生一个值<code>seq=x</code>，并将该数据包发送给Server，Client进入<code>SYN_SENT</code>状态，等待Server确认。</li>
<li><p>Server收到数据包后由标志位<code>SYN=1</code>知道Client请求建立连接，Server将标志位<code>SYN和ACK</code>都置为<code>1</code>，并设置确认号<code>ack=x+1</code>，随机产生一个值<code>seq=y</code>，并将该数据包发送给Client以确认连接请求，Server进入<code>SYN_RCVD</code>状态。</p>
</li>
<li><p>Client收到确认后，检查确认号ack是否为<code>x+1</code>，ACK是否为<code>1</code>，如果正确则将标志位ACK置为1，确认号<code>ack=y+1</code>，并将该数据包发送给Server，Server检查确认号<code>ack</code>是否为<code>y+1</code>，ACK是否为<code>1</code>，seq是否为<code>x+1</code>如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ol>
<blockquote>
<p>SYN：同步序列编号(Synchronize Sequence Numbers)</p>
<p>ACK： 确认值（Acknowledgement ）</p>
<p>ack：确认编号（ Acknowledgement Number ）</p>
</blockquote>
<p><img src="/2020/05/23/Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/四次握手.jpeg" alt="四次握手"></p>
<p>四次挥手：</p>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<ol>
<li><p>数据传输结束后，客户端的应用进程发出连接释放报文段，标志位<code>FIN为1</code>，<code>seq为u</code>，并停止发送数据，客户端进入<code>FIN_WAIT-1</code>状态，此时客户端依然可以接收服务器发送来的数据。</p>
</li>
<li><p>服务器接收到报文后，发送一个<code>ACK</code>给客户端，确认号ack为<code>u+1</code>，产生序列号seq为<code>v</code>，服务器进入<code>CLOSE_WAIT</code>状态。客户端收到后进入<code>FIN_WAIT-2</code>状态。</p>
</li>
<li><p>当服务器没有数据要发送时，服务器发送一个<code>FIN</code>为<code>1</code>，ACK为<code>1</code>报文，序列号<code>seq为w</code>，确认号ack为<code>u+1</code>，此时服务器进入<code>LAST_ACK</code>状态，等待客户端的确认</p>
</li>
<li><p>客户端收到服务器的报文后，给服务器发送一个ACK为<code>1</code>，确认序列号为<code>w+1</code>。此时客户端进入<code>TIME_WAIT</code>状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</p>
</li>
</ol>
<h2 id="为什么是3次握手"><a href="#为什么是3次握手" class="headerlink" title="为什么是3次握手"></a>为什么是3次握手</h2><p>第一次握手：</p>
<pre><code>Client什么都不能确认   
Server确认了对方发送正常
</code></pre><p>第二次握手：</p>
<pre><code>Client确认：自己发送/接收正常，对方发送/接收正常
Server确认：自己接收正常 ，对方发送正常
</code></pre><p>第三次握手：</p>
<pre><code>Client确认：自己发送/接收正常， 对方发送/接收正常
Server确认：自己发送/接收正常，对方发送/接收正常
</code></pre><h2 id="两次握手会怎么样"><a href="#两次握手会怎么样" class="headerlink" title="两次握手会怎么样"></a>两次握手会怎么样</h2><p><img src="/2020/05/23/Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/两次握手.png" alt></p>
<p>有这样一种情况，当A发送一个消息给B，但是由于网络原因，消息被阻塞在了某个节点，然后阻塞的时间超出设定的时间，A会认为这个消息丢失了，然后重新发送消息。</p>
<p>当A和B通信完成后，这个被A认为失效的消息，到达了B<br>对于B而言，以为这是一个新的请求链接消息，就向A发送确认，<br>对于A而言，它认为没有给B再次发送消息（因为上次的通话已经结束）所有A不会理睬B的这个确认，但是B则会一直等待A的消息</p>
<p>这就导致了B的时间被浪费（对于服务器而言，CPU等资源是一种浪费），这样是不可行的，这就是为什么不能两次握手的原因了。</p>
<h2 id="为什么建立连接是3次，关闭是4次"><a href="#为什么建立连接是3次，关闭是4次" class="headerlink" title="为什么建立连接是3次，关闭是4次"></a>为什么建立连接是3次，关闭是4次</h2><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。 </p>
<p>这是因为服务端当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你未必会马上会关闭连接,即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 </p>
<h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><ol>
<li><p>http协议是以明文的方式在网络中传输数据，而https协议传输的数据则是经过TLS加密后的，httpS具有更高的安全性</p>
</li>
<li><p>https在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p>
</li>
<li><p>https协议需要服务端申请证书，浏览器端安装对应的根证书</p>
</li>
<li><p>http协议端口是80，httpS协议端口是443</p>
</li>
</ol>
<p>https优点：</p>
<ul>
<li><p>https传输数据过程中使用密钥进行加密，所以安全性更高</p>
</li>
<li><p>https协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</p>
</li>
</ul>
<p>https缺点：</p>
<ul>
<li><p>https握手阶段延时较高：由于在进行http会话之前还需要进行SSL握手，因此https协议握手阶段延时增加</p>
</li>
<li><p>https部署成本高：一方面https协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用https协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</p>
</li>
</ul>
<h2 id="OSI七层模型和TCP-IP四层模型"><a href="#OSI七层模型和TCP-IP四层模型" class="headerlink" title="OSI七层模型和TCP/IP四层模型"></a>OSI七层模型和TCP/IP四层模型</h2><p><img src="/2020/05/23/Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/OSI+TCP.png" alt="OSI七层模型和TCP/IP四层模型"></p>
<ul>
<li><p>OSI七层模型及其包含的协议如下:</p>
<ul>
<li>物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45</li>
<li>数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP</li>
<li>网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP</li>
<li>传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP</li>
<li>会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS</li>
<li>表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII</li>
<li>应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS</li>
</ul>
</li>
<li><p>TCP/IP 4层模型包括：</p>
<ul>
<li>数据链路层：MAC VLAN</li>
<li>网络层:IP ARP ICMP</li>
<li>传输层:TCP UDP</li>
<li>应用层:HTTP DNS SMTP</li>
</ul>
</li>
</ul>
<h2 id="TCP和UDP的区别和各自适用的场景"><a href="#TCP和UDP的区别和各自适用的场景" class="headerlink" title="TCP和UDP的区别和各自适用的场景"></a>TCP和UDP的区别和各自适用的场景</h2><p>TCP和UDP区别</p>
<ol>
<li><p>连接</p>
<ul>
<li>TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。</li>
<li>UDP无连接。</li>
</ul>
</li>
<li><p>服务对象</p>
<ul>
<li>TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；</li>
<li>UDP支持一对一，一对多，多对一，多对多的交互通信。</li>
</ul>
</li>
<li><p>可靠性</p>
<ul>
<li>TCP是可靠交付：无差错，不丢失，不重复，按序到达。</li>
<li>UDP是尽最大努力交付，不保证可靠交付。</li>
</ul>
</li>
<li><p>拥塞控制，流量控制</p>
<ul>
<li>TCP有拥塞控制和流量控制保证数据传输的安全性。</li>
<li>没有拥塞控制，网络拥塞不会影响源主机的发送效率。</li>
</ul>
</li>
<li><p>报文长度</p>
<ul>
<li>TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</li>
<li>UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</li>
</ul>
</li>
<li><p>首部开销</p>
<ul>
<li>TCP首部开销大，首部20个字节。</li>
<li>UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）</li>
</ul>
</li>
</ol>
<p>TCP和UDP适用场景</p>
<ul>
<li><p>从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。</p>
</li>
<li><p>若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</p>
</li>
</ul>
<h2 id="socket编程中服务器端和客户端主要用到哪些函数"><a href="#socket编程中服务器端和客户端主要用到哪些函数" class="headerlink" title="socket编程中服务器端和客户端主要用到哪些函数"></a>socket编程中服务器端和客户端主要用到哪些函数</h2><p>基于TCP的socket：</p>
<p><img src="/2020/05/23/Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/socket.png" alt></p>
<ul>
<li><p>服务器端程序：</p>
<ul>
<li>创建一个socket，用函数socket()</li>
<li>绑定IP地址、端口等信息到socket上，用函数bind()</li>
<li>设置允许的最大连接数，用函数listen()</li>
<li>接收客户端上来的连接，用函数accept()</li>
<li>收发数据，用函数send()和recv()，或者read()和write()</li>
<li>关闭网络连接</li>
</ul>
</li>
<li><p>客户端程序：</p>
<ul>
<li>创建一个socket，用函数socket()</li>
<li>设置要连接的对方的IP地址和端口等属性</li>
<li>连接服务器，用函数connect()</li>
<li>收发数据，用函数send()和recv()，或read()和write()</li>
<li>关闭网络连接</li>
</ul>
</li>
</ul>
<p>基于UDP的socket：</p>
<p><img src="/2020/05/23/Cpp%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/blog\source\_posts\Cpp面经总结\308571_1552654687053_263E6AFD1A48F8511D04B67EB12AA24C" alt="UDP的socket" style="zoom:50%;"></p>
<ul>
<li><p>服务器端流程</p>
<ul>
<li>建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。</li>
<li>设置服务器地址和侦听端口，初始化要绑定的网络地址结构。</li>
<li>绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。</li>
<li>接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。</li>
<li>向客户端发送数据，使用sendto()函数向服务器主机发送数据。</li>
<li>关闭套接字，使用close()函数释放资源。UDP协议的客户端流程</li>
</ul>
</li>
<li><p>客户端流程</p>
<ul>
<li>建立套接字文件描述符，socket()。</li>
<li>设置服务器地址和端口，struct sockaddr。</li>
<li>向服务器发送数据，sendto()。</li>
<li>接收服务器的数据，recvfrom()。</li>
<li>关闭套接字，close()。</li>
</ul>
</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="索引及其作用和实现方法："><a href="#索引及其作用和实现方法：" class="headerlink" title="索引及其作用和实现方法："></a>索引及其作用和实现方法：</h2><ul>
<li>概念： <strong>索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。</strong> </li>
<li>作用：加快查找速度；</li>
<li>实现方法：一般分为B+树索引和哈希索引。<ul>
<li>B+树索引：在B-tree上改进得到，其非叶子节点均为key值，叶子节点是key-data键值对。叶子节点前后相连且有序。</li>
<li>哈希索引：通过对key进行数据hash进行存储。</li>
<li>为什么有了B+树索引还要hash索引？<ol>
<li>B+树默认有序，hash默认无序，所以哈希索引无法用于排序；</li>
<li>哈希索引O(1)在速度上毋庸置疑要快于B+树近似O(logn);</li>
<li>哈希索引只能进行等值查询（因为他要计算hash(key)再去匹配）而B+树索引可以进行等值、部分前缀、范围查询；</li>
<li>对于某些场景如热点页/活跃查询页，需要借助哈希索引来实现快速查询。</li>
</ol>
</li>
</ul>
</li>
<li>索引越多越快？<ul>
<li>此言差矣，索引并非是虚无缥缈的，是实实在在的一种数据结构（B+树/hash桶）要占内存、维护它要系统开销，一般的插入删除都要进行结构的调整，这要消耗时间，所以索引太多反而拖慢查找时间。有时候，见数据量不多时，建立索引还不如全表查询。索引加快了检索的速度，但是插入删除修改都需要DBMS动态更新内部索引结构，要耗费开销。</li>
</ul>
</li>
<li>为什么B+比B树更适合文件索引和数据库索引<ul>
<li>B+的磁盘读取代价更低，没有指向关键字具体信息的指针，内部结构相较B树更小。</li>
<li>B+查询效果更稳定，每次查询都是相同查询路径</li>
</ul>
</li>
</ul>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><ul>
<li><strong>唯一索引</strong>：唯一索引不允许两行具有相同的索引值</li>
<li><strong>主键索引</strong>：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空</li>
<li><strong>聚集索引(Clustered)</strong>：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li>
<li><strong>非聚集索引(Non-clustered)</strong>：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个</li>
</ul>
<h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>① 通过创建索引,可以在查询的过程中,提高系统的性能</p>
<p>② 通过创建唯一性索引,可以保证数据库表中每一行数据的唯一性</p>
<p>③ 在使用分组和排序子句进行数据检索时,可以减少查询中分组和排序的时间</p>
<h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><p>① 创建索引和维护索引要耗费时间,而且时间随着数据量的增加而增大</p>
<p>② 索引需要占用物理空间,如果要建立聚簇索引,所需要的空间会更大</p>
<p>③ 在对表中的数据进行增加删除和修改时需要耗费较多的时间,因为索引也要动态地维护</p>
<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>数据库中一组原子性的SQL操作，彼此状态一致。具有ACID特性。 </p>
<p>事务 ACID 特性：</p>
<ul>
<li>原子性（Atomicity）：事务作为一个整体被执行 ，要么全部执行，要么全部不执行</li>
<li>一致性（Consistency）：保证数据库状态从一个一致状态转变为另一个一致状态</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li>
<li>持久性（Durability）：一个事务一旦提交，对数据库的修改应该永久保存</li>
</ul>
<h2 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h2><ul>
<li><p>第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分</p>
</li>
<li><p>第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式</p>
</li>
<li><p>第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码</p>
</li>
</ul>
<h2 id="事务的并发问题有哪几种？"><a href="#事务的并发问题有哪几种？" class="headerlink" title="事务的并发问题有哪几种？"></a>事务的并发问题有哪几种？</h2><ol>
<li>丢失更新：一个事务的更新覆盖了另一个事务的更新；</li>
<li>脏读：一个事务读取了另一个事务未提交的数据；</li>
<li>不可重复读：不可重复读的重点是修改，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；</li>
<li>幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样。</li>
</ol>
<h2 id="MySQL-4中隔离级别"><a href="#MySQL-4中隔离级别" class="headerlink" title="MySQL 4中隔离级别"></a>MySQL 4中隔离级别</h2><ul>
<li>未提交读READ UNCOMMITTED：一个事务在提交之前，对其他事务是可见的，即事务可以读取未提交的数据。存在“脏读”（读到了脏数据）问题；</li>
<li>提交读READ COMMITTED：事务在提交之前，对其它事务是不可见的。存在“不可重复读”（两次查询的得到的结果可能不同，即可能在查询的间隙，有事务提交了修改）问题。解决了“脏读”问题。</li>
<li>可重复读REPEATABLE READ：在同一事务中多次读取的数据是一致的。解决了脏读和不可重复读问题，存在“幻读”（在事务两次查询间隙，有其他事务又插入或删除了新的记录）。—- MySQL默认隔离级别。</li>
<li>可串行化SERIALIZABLE：强制事务串行化执行。即一个事物一个事物挨个来执行，可以解决上述所有问题。</li>
</ul>
<h2 id="锁和粒度"><a href="#锁和粒度" class="headerlink" title="锁和粒度"></a>锁和粒度</h2><ul>
<li>共享锁/读锁：互不阻塞，优先级低。</li>
<li>排他锁/写锁：阻塞其他锁，优先级高，即确保在一个事务写入时不受其他事务的影响。</li>
<li>锁粒度：锁定的数据量越少（粒度越小），并发程度越高，但相应的加锁、检测锁、释放锁用的系统开销也随之增大。</li>
<li>锁策略：锁开销与数据安全性之间的平衡<ul>
<li>表锁：锁住整张表，读锁互不阻塞，写锁阻塞其他所有读写锁（同一张表）。开销最小。</li>
<li>行级锁：对每一行数据（记录）加锁，开销大，并发程度高。</li>
</ul>
</li>
</ul>
<h2 id="MySQL存储引擎简介"><a href="#MySQL存储引擎简介" class="headerlink" title="MySQL存储引擎简介"></a>MySQL存储引擎简介</h2><ul>
<li><p>InnoDB,最为通用/推荐的一种引擎，支持事务、行级锁、甚至间隙锁（避免幻读）、支持热备份，MVCC，在并发上占优势，系统资源占用多。</p>
</li>
<li><p>MyISAM,默认的存储引擎，不支持事务和行级锁，只支持表锁，某些场景性能很好：占用存储上优，查询速度上完胜（大概是InnoDB的3倍）系统资源占用少。</p>
</li>
<li><p>InnoDB支持事务, MyISAM不支持；</p>
</li>
<li><p>InnoDB支持行级锁、表锁；MyISAM只支持表锁；</p>
</li>
<li><p>InnoDB支持MVCC，MyISAM不支持；</p>
</li>
<li><p>InnoDB不支持全文索引，MyISAM支持；</p>
</li>
<li><p>InnoDB支持外键，MyISAM不支持外键；</p>
</li>
<li><p>InnoDB和MyISAM都支持B+树索引，InnoDB还支持自适应哈希索引</p>
</li>
<li><p>MyISAM实现了前缀压缩技术，占用存储空间更小（但会影响查找），InnoDB是原始数据存储，占用存储更大。</p>
<p>PS：大部分情况下，InnoDB都是正确的选择。—-《高性能MySQL》</p>
</li>
</ul>
<h2 id="MySQL查询的步骤"><a href="#MySQL查询的步骤" class="headerlink" title="MySQL查询的步骤"></a>MySQL查询的步骤</h2><ul>
<li>客户端发送查询到服务器；</li>
<li>服务器检查查询缓存query <em>*</em>（大小写敏感的哈希查找，常数时间）。如果命中，返回缓存中的结果，否则下一步；</li>
<li>解析语句，生成执行计划；（SQL解析，预处理，优化器生成执行计划）；</li>
<li>根据执行计划，根据存储引擎的不同调用API，执行查询（一棵指令树）；</li>
<li>结果返回客户端。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"># 面经</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/03/Cpp-STL/" rel="prev" title="Cpp-STL">
      <i class="fa fa-chevron-left"></i> Cpp-STL
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/23/SQL%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/" rel="next" title="SQL语法规则">
      SQL语法规则 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#c-的面试总结"><span class="nav-number">1.</span> <span class="nav-text">c++的面试总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C"><span class="nav-number">2.</span> <span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#new-delet和malloc-free的区别"><span class="nav-number">2.1.</span> <span class="nav-text">new/delet和malloc/free的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static关键字的作用"><span class="nav-number">2.2.</span> <span class="nav-text">static关键字的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-和C的区别"><span class="nav-number">2.3.</span> <span class="nav-text">C++和C的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是多态"><span class="nav-number">2.4.</span> <span class="nav-text">什么是多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是虚函数"><span class="nav-number">2.5.</span> <span class="nav-text">什么是虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态函数和虚函数的区别"><span class="nav-number">2.6.</span> <span class="nav-text">静态函数和虚函数的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-中四种cast转换"><span class="nav-number">2.7.</span> <span class="nav-text">C++中四种cast转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针和引用的区别"><span class="nav-number">2.8.</span> <span class="nav-text">指针和引用的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针和数组的区别"><span class="nav-number">2.9.</span> <span class="nav-text">指针和数组的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是野指针"><span class="nav-number">2.10.</span> <span class="nav-text">什么是野指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-的四个智能指针"><span class="nav-number">2.11.</span> <span class="nav-text">C++的四个智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么析构函数必须是虚函数？"><span class="nav-number">2.12.</span> <span class="nav-text">为什么析构函数必须是虚函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么C-默认的析构函数不是虚函数"><span class="nav-number">2.13.</span> <span class="nav-text">为什么C++默认的析构函数不是虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#析构函数的作用"><span class="nav-number">2.14.</span> <span class="nav-text">析构函数的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是函数指针"><span class="nav-number">2.15.</span> <span class="nav-text">什么是函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载和重写"><span class="nav-number">2.16.</span> <span class="nav-text">重载和重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strcpy和strlen"><span class="nav-number">2.17.</span> <span class="nav-text">strcpy和strlen</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C语言是怎么进行函数调用的"><span class="nav-number">2.18.</span> <span class="nav-text">C语言是怎么进行函数调用的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-如何处理返回值"><span class="nav-number">2.19.</span> <span class="nav-text">C++如何处理返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-中拷贝赋值函数的形参能否进行值传递？"><span class="nav-number">2.20.</span> <span class="nav-text">C++中拷贝赋值函数的形参能否进行值传递？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#权限修饰符"><span class="nav-number">2.21.</span> <span class="nav-text">权限修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体和类有什么区别"><span class="nav-number">2.22.</span> <span class="nav-text">结构体和类有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11有哪些新特性？"><span class="nav-number">2.23.</span> <span class="nav-text">C++11有哪些新特性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体struct和共同体union（联合）的区别"><span class="nav-number">2.24.</span> <span class="nav-text">结构体struct和共同体union（联合）的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL"><span class="nav-number">3.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STL有什么基本组成"><span class="nav-number">3.1.</span> <span class="nav-text">STL有什么基本组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map和set"><span class="nav-number">3.2.</span> <span class="nav-text">map和set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unordered-map"><span class="nav-number">3.3.</span> <span class="nav-text">unordered_map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multimap"><span class="nav-number">3.4.</span> <span class="nav-text">multimap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vector-和-List"><span class="nav-number">3.5.</span> <span class="nav-text">Vector 和 List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL迭代器删除元素"><span class="nav-number">3.6.</span> <span class="nav-text">STL迭代器删除元素</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统"><span class="nav-number">4.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程的概念"><span class="nav-number">4.1.</span> <span class="nav-text">进程与线程的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程与进程的区别"><span class="nav-number">4.2.</span> <span class="nav-text">线程与进程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信的方式"><span class="nav-number">4.3.</span> <span class="nav-text">进程间通信的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发-concurrency-和并行-parallelism"><span class="nav-number">4.4.</span> <span class="nav-text">并发(concurrency)和并行(parallelism)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程和多进程的不同"><span class="nav-number">4.5.</span> <span class="nav-text">多线程和多进程的不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何定义多线程"><span class="nav-number">4.6.</span> <span class="nav-text">如何定义多线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络"><span class="nav-number">5.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP的建立与断开过程"><span class="nav-number">5.1.</span> <span class="nav-text">TCP的建立与断开过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么是3次握手"><span class="nav-number">5.2.</span> <span class="nav-text">为什么是3次握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两次握手会怎么样"><span class="nav-number">5.3.</span> <span class="nav-text">两次握手会怎么样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么建立连接是3次，关闭是4次"><span class="nav-number">5.4.</span> <span class="nav-text">为什么建立连接是3次，关闭是4次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http和https的区别"><span class="nav-number">5.5.</span> <span class="nav-text">http和https的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OSI七层模型和TCP-IP四层模型"><span class="nav-number">5.6.</span> <span class="nav-text">OSI七层模型和TCP/IP四层模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP和UDP的区别和各自适用的场景"><span class="nav-number">5.7.</span> <span class="nav-text">TCP和UDP的区别和各自适用的场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket编程中服务器端和客户端主要用到哪些函数"><span class="nav-number">5.8.</span> <span class="nav-text">socket编程中服务器端和客户端主要用到哪些函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库"><span class="nav-number">6.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#索引及其作用和实现方法："><span class="nav-number">6.1.</span> <span class="nav-text">索引及其作用和实现方法：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引的分类"><span class="nav-number">6.2.</span> <span class="nav-text">索引的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的优点"><span class="nav-number">6.2.1.</span> <span class="nav-text">索引的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的缺点"><span class="nav-number">6.2.2.</span> <span class="nav-text">索引的缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库事务"><span class="nav-number">6.3.</span> <span class="nav-text">数据库事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库的三大范式"><span class="nav-number">6.4.</span> <span class="nav-text">数据库的三大范式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务的并发问题有哪几种？"><span class="nav-number">6.5.</span> <span class="nav-text">事务的并发问题有哪几种？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-4中隔离级别"><span class="nav-number">6.6.</span> <span class="nav-text">MySQL 4中隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁和粒度"><span class="nav-number">6.7.</span> <span class="nav-text">锁和粒度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL存储引擎简介"><span class="nav-number">6.8.</span> <span class="nav-text">MySQL存储引擎简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL查询的步骤"><span class="nav-number">6.9.</span> <span class="nav-text">MySQL查询的步骤</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Alex Li"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Alex Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Li</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">200k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:34</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共90.7k字</span>
</div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  


  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>

</body>
</html>
